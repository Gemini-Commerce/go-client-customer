/*
CDP Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: info@gemini-commerce.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package customer

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type CustomerAPI interface {

	/*
	CustomerAcquireSubscriber Method for CustomerAcquireSubscriber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAcquireSubscriberRequest
	*/
	CustomerAcquireSubscriber(ctx context.Context) CustomerAPICustomerAcquireSubscriberRequest

	// CustomerAcquireSubscriberExecute executes the request
	//  @return CustomerSubscriberResponse
	CustomerAcquireSubscriberExecute(r CustomerAPICustomerAcquireSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerAcquireSubscriber2 Method for CustomerAcquireSubscriber2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAcquireSubscriber2Request
	*/
	CustomerAcquireSubscriber2(ctx context.Context) CustomerAPICustomerAcquireSubscriber2Request

	// CustomerAcquireSubscriber2Execute executes the request
	//  @return CustomerSubscriberResponse
	CustomerAcquireSubscriber2Execute(r CustomerAPICustomerAcquireSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerAcquireUnsubscriber Method for CustomerAcquireUnsubscriber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAcquireUnsubscriberRequest
	*/
	CustomerAcquireUnsubscriber(ctx context.Context) CustomerAPICustomerAcquireUnsubscriberRequest

	// CustomerAcquireUnsubscriberExecute executes the request
	//  @return CustomerUnsubscribeResponse
	CustomerAcquireUnsubscriberExecute(r CustomerAPICustomerAcquireUnsubscriberRequest) (*CustomerUnsubscribeResponse, *http.Response, error)

	/*
	CustomerAcquireUnsubscriber2 Method for CustomerAcquireUnsubscriber2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAcquireUnsubscriber2Request
	*/
	CustomerAcquireUnsubscriber2(ctx context.Context) CustomerAPICustomerAcquireUnsubscriber2Request

	// CustomerAcquireUnsubscriber2Execute executes the request
	//  @return CustomerUnsubscribeResponse
	CustomerAcquireUnsubscriber2Execute(r CustomerAPICustomerAcquireUnsubscriber2Request) (*CustomerUnsubscribeResponse, *http.Response, error)

	/*
	CustomerAddCustomerToGroup Method for CustomerAddCustomerToGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAddCustomerToGroupRequest
	*/
	CustomerAddCustomerToGroup(ctx context.Context) CustomerAPICustomerAddCustomerToGroupRequest

	// CustomerAddCustomerToGroupExecute executes the request
	//  @return CustomerGroupResponse
	CustomerAddCustomerToGroupExecute(r CustomerAPICustomerAddCustomerToGroupRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerAddCustomerToGroup2 Method for CustomerAddCustomerToGroup2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAddCustomerToGroup2Request
	*/
	CustomerAddCustomerToGroup2(ctx context.Context) CustomerAPICustomerAddCustomerToGroup2Request

	// CustomerAddCustomerToGroup2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerAddCustomerToGroup2Execute(r CustomerAPICustomerAddCustomerToGroup2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerAssignAgent Method for CustomerAssignAgent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerAssignAgentRequest
	*/
	CustomerAssignAgent(ctx context.Context) CustomerAPICustomerAssignAgentRequest

	// CustomerAssignAgentExecute executes the request
	//  @return map[string]interface{}
	CustomerAssignAgentExecute(r CustomerAPICustomerAssignAgentRequest) (map[string]interface{}, *http.Response, error)

	/*
	CustomerBulkUpdate Method for CustomerBulkUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerBulkUpdateRequest
	*/
	CustomerBulkUpdate(ctx context.Context) CustomerAPICustomerBulkUpdateRequest

	// CustomerBulkUpdateExecute executes the request
	//  @return CustomerBulkUpdateResponse
	CustomerBulkUpdateExecute(r CustomerAPICustomerBulkUpdateRequest) (*CustomerBulkUpdateResponse, *http.Response, error)

	/*
	CustomerBulkUpdate2 Method for CustomerBulkUpdate2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerBulkUpdate2Request
	*/
	CustomerBulkUpdate2(ctx context.Context) CustomerAPICustomerBulkUpdate2Request

	// CustomerBulkUpdate2Execute executes the request
	//  @return CustomerBulkUpdateResponse
	CustomerBulkUpdate2Execute(r CustomerAPICustomerBulkUpdate2Request) (*CustomerBulkUpdateResponse, *http.Response, error)

	/*
	CustomerCreate Method for CustomerCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateRequest
	*/
	CustomerCreate(ctx context.Context) CustomerAPICustomerCreateRequest

	// CustomerCreateExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerCreateExecute(r CustomerAPICustomerCreateRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerCreate2 Method for CustomerCreate2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreate2Request
	*/
	CustomerCreate2(ctx context.Context) CustomerAPICustomerCreate2Request

	// CustomerCreate2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerCreate2Execute(r CustomerAPICustomerCreate2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerCreateAddress Method for CustomerCreateAddress

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateAddressRequest
	*/
	CustomerCreateAddress(ctx context.Context) CustomerAPICustomerCreateAddressRequest

	// CustomerCreateAddressExecute executes the request
	//  @return CustomerAddressCustomerResponse
	CustomerCreateAddressExecute(r CustomerAPICustomerCreateAddressRequest) (*CustomerAddressCustomerResponse, *http.Response, error)

	/*
	CustomerCreateAddress2 Method for CustomerCreateAddress2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateAddress2Request
	*/
	CustomerCreateAddress2(ctx context.Context) CustomerAPICustomerCreateAddress2Request

	// CustomerCreateAddress2Execute executes the request
	//  @return CustomerAddressCustomerResponse
	CustomerCreateAddress2Execute(r CustomerAPICustomerCreateAddress2Request) (*CustomerAddressCustomerResponse, *http.Response, error)

	/*
	CustomerCreateGroup Method for CustomerCreateGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateGroupRequest
	*/
	CustomerCreateGroup(ctx context.Context) CustomerAPICustomerCreateGroupRequest

	// CustomerCreateGroupExecute executes the request
	//  @return CustomerGroupResponse
	CustomerCreateGroupExecute(r CustomerAPICustomerCreateGroupRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerCreateGroup2 Method for CustomerCreateGroup2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateGroup2Request
	*/
	CustomerCreateGroup2(ctx context.Context) CustomerAPICustomerCreateGroup2Request

	// CustomerCreateGroup2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerCreateGroup2Execute(r CustomerAPICustomerCreateGroup2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerCreateSubscriber Method for CustomerCreateSubscriber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateSubscriberRequest
	*/
	CustomerCreateSubscriber(ctx context.Context) CustomerAPICustomerCreateSubscriberRequest

	// CustomerCreateSubscriberExecute executes the request
	//  @return CustomerSubscriberResponse
	CustomerCreateSubscriberExecute(r CustomerAPICustomerCreateSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerCreateSubscriber2 Method for CustomerCreateSubscriber2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerCreateSubscriber2Request
	*/
	CustomerCreateSubscriber2(ctx context.Context) CustomerAPICustomerCreateSubscriber2Request

	// CustomerCreateSubscriber2Execute executes the request
	//  @return CustomerSubscriberResponse
	CustomerCreateSubscriber2Execute(r CustomerAPICustomerCreateSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerDeleteAddress Method for CustomerDeleteAddress

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerDeleteAddressRequest
	*/
	CustomerDeleteAddress(ctx context.Context) CustomerAPICustomerDeleteAddressRequest

	// CustomerDeleteAddressExecute executes the request
	//  @return CustomerAddressDeleteResponse
	CustomerDeleteAddressExecute(r CustomerAPICustomerDeleteAddressRequest) (*CustomerAddressDeleteResponse, *http.Response, error)

	/*
	CustomerDeleteAddress2 Method for CustomerDeleteAddress2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerDeleteAddress2Request
	*/
	CustomerDeleteAddress2(ctx context.Context) CustomerAPICustomerDeleteAddress2Request

	// CustomerDeleteAddress2Execute executes the request
	//  @return CustomerAddressDeleteResponse
	CustomerDeleteAddress2Execute(r CustomerAPICustomerDeleteAddress2Request) (*CustomerAddressDeleteResponse, *http.Response, error)

	/*
	CustomerDeleteGroup Method for CustomerDeleteGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerDeleteGroupRequest
	*/
	CustomerDeleteGroup(ctx context.Context) CustomerAPICustomerDeleteGroupRequest

	// CustomerDeleteGroupExecute executes the request
	//  @return CustomerDeleteGroupResponse
	CustomerDeleteGroupExecute(r CustomerAPICustomerDeleteGroupRequest) (*CustomerDeleteGroupResponse, *http.Response, error)

	/*
	CustomerDeleteGroup2 Method for CustomerDeleteGroup2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerDeleteGroup2Request
	*/
	CustomerDeleteGroup2(ctx context.Context) CustomerAPICustomerDeleteGroup2Request

	// CustomerDeleteGroup2Execute executes the request
	//  @return CustomerDeleteGroupResponse
	CustomerDeleteGroup2Execute(r CustomerAPICustomerDeleteGroup2Request) (*CustomerDeleteGroupResponse, *http.Response, error)

	/*
	CustomerFind Method for CustomerFind

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindRequest
	*/
	CustomerFind(ctx context.Context) CustomerAPICustomerFindRequest

	// CustomerFindExecute executes the request
	//  @return CustomerFindManyResponse
	CustomerFindExecute(r CustomerAPICustomerFindRequest) (*CustomerFindManyResponse, *http.Response, error)

	/*
	CustomerFind2 Method for CustomerFind2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFind2Request
	*/
	CustomerFind2(ctx context.Context) CustomerAPICustomerFind2Request

	// CustomerFind2Execute executes the request
	//  @return CustomerFindManyResponse
	CustomerFind2Execute(r CustomerAPICustomerFind2Request) (*CustomerFindManyResponse, *http.Response, error)

	/*
	CustomerFindByEmail Method for CustomerFindByEmail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindByEmailRequest
	*/
	CustomerFindByEmail(ctx context.Context) CustomerAPICustomerFindByEmailRequest

	// CustomerFindByEmailExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerFindByEmailExecute(r CustomerAPICustomerFindByEmailRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerFindByEmail2 Method for CustomerFindByEmail2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindByEmail2Request
	*/
	CustomerFindByEmail2(ctx context.Context) CustomerAPICustomerFindByEmail2Request

	// CustomerFindByEmail2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerFindByEmail2Execute(r CustomerAPICustomerFindByEmail2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerFindById Method for CustomerFindById

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindByIdRequest
	*/
	CustomerFindById(ctx context.Context) CustomerAPICustomerFindByIdRequest

	// CustomerFindByIdExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerFindByIdExecute(r CustomerAPICustomerFindByIdRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerFindById2 Method for CustomerFindById2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindById2Request
	*/
	CustomerFindById2(ctx context.Context) CustomerAPICustomerFindById2Request

	// CustomerFindById2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerFindById2Execute(r CustomerAPICustomerFindById2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerFindSubscriberByEmail Method for CustomerFindSubscriberByEmail

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindSubscriberByEmailRequest
	*/
	CustomerFindSubscriberByEmail(ctx context.Context) CustomerAPICustomerFindSubscriberByEmailRequest

	// CustomerFindSubscriberByEmailExecute executes the request
	//  @return CustomerSubscriberResponse
	CustomerFindSubscriberByEmailExecute(r CustomerAPICustomerFindSubscriberByEmailRequest) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerFindSubscriberByEmail2 Method for CustomerFindSubscriberByEmail2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindSubscriberByEmail2Request
	*/
	CustomerFindSubscriberByEmail2(ctx context.Context) CustomerAPICustomerFindSubscriberByEmail2Request

	// CustomerFindSubscriberByEmail2Execute executes the request
	//  @return CustomerSubscriberResponse
	CustomerFindSubscriberByEmail2Execute(r CustomerAPICustomerFindSubscriberByEmail2Request) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerFindSubscriberById Method for CustomerFindSubscriberById

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindSubscriberByIdRequest
	*/
	CustomerFindSubscriberById(ctx context.Context) CustomerAPICustomerFindSubscriberByIdRequest

	// CustomerFindSubscriberByIdExecute executes the request
	//  @return CustomerSubscriberResponse
	CustomerFindSubscriberByIdExecute(r CustomerAPICustomerFindSubscriberByIdRequest) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerFindSubscriberById2 Method for CustomerFindSubscriberById2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerFindSubscriberById2Request
	*/
	CustomerFindSubscriberById2(ctx context.Context) CustomerAPICustomerFindSubscriberById2Request

	// CustomerFindSubscriberById2Execute executes the request
	//  @return CustomerSubscriberResponse
	CustomerFindSubscriberById2Execute(r CustomerAPICustomerFindSubscriberById2Request) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerGetGroupByCode Method for CustomerGetGroupByCode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGetGroupByCodeRequest
	*/
	CustomerGetGroupByCode(ctx context.Context) CustomerAPICustomerGetGroupByCodeRequest

	// CustomerGetGroupByCodeExecute executes the request
	//  @return CustomerGroupResponse
	CustomerGetGroupByCodeExecute(r CustomerAPICustomerGetGroupByCodeRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerGetGroupByCode2 Method for CustomerGetGroupByCode2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGetGroupByCode2Request
	*/
	CustomerGetGroupByCode2(ctx context.Context) CustomerAPICustomerGetGroupByCode2Request

	// CustomerGetGroupByCode2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerGetGroupByCode2Execute(r CustomerAPICustomerGetGroupByCode2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerGetGroupById Method for CustomerGetGroupById

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGetGroupByIdRequest
	*/
	CustomerGetGroupById(ctx context.Context) CustomerAPICustomerGetGroupByIdRequest

	// CustomerGetGroupByIdExecute executes the request
	//  @return CustomerGroupResponse
	CustomerGetGroupByIdExecute(r CustomerAPICustomerGetGroupByIdRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerGetGroupById2 Method for CustomerGetGroupById2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGetGroupById2Request
	*/
	CustomerGetGroupById2(ctx context.Context) CustomerAPICustomerGetGroupById2Request

	// CustomerGetGroupById2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerGetGroupById2Execute(r CustomerAPICustomerGetGroupById2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerGrantPermissions Method for CustomerGrantPermissions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGrantPermissionsRequest
	*/
	CustomerGrantPermissions(ctx context.Context) CustomerAPICustomerGrantPermissionsRequest

	// CustomerGrantPermissionsExecute executes the request
	//  @return map[string]interface{}
	CustomerGrantPermissionsExecute(r CustomerAPICustomerGrantPermissionsRequest) (map[string]interface{}, *http.Response, error)

	/*
	CustomerGrantPermissions2 Method for CustomerGrantPermissions2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerGrantPermissions2Request
	*/
	CustomerGrantPermissions2(ctx context.Context) CustomerAPICustomerGrantPermissions2Request

	// CustomerGrantPermissions2Execute executes the request
	//  @return map[string]interface{}
	CustomerGrantPermissions2Execute(r CustomerAPICustomerGrantPermissions2Request) (map[string]interface{}, *http.Response, error)

	/*
	CustomerListConsents ListConsents list all consents of a customer

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerListConsentsRequest
	*/
	CustomerListConsents(ctx context.Context) CustomerAPICustomerListConsentsRequest

	// CustomerListConsentsExecute executes the request
	//  @return CustomerListConsentsResponse
	CustomerListConsentsExecute(r CustomerAPICustomerListConsentsRequest) (*CustomerListConsentsResponse, *http.Response, error)

	/*
	CustomerListCustomers Method for CustomerListCustomers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerListCustomersRequest
	*/
	CustomerListCustomers(ctx context.Context) CustomerAPICustomerListCustomersRequest

	// CustomerListCustomersExecute executes the request
	//  @return CustomerListCustomersResponse
	CustomerListCustomersExecute(r CustomerAPICustomerListCustomersRequest) (*CustomerListCustomersResponse, *http.Response, error)

	/*
	CustomerListCustomers2 Method for CustomerListCustomers2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerListCustomers2Request
	*/
	CustomerListCustomers2(ctx context.Context) CustomerAPICustomerListCustomers2Request

	// CustomerListCustomers2Execute executes the request
	//  @return CustomerListCustomersResponse
	CustomerListCustomers2Execute(r CustomerAPICustomerListCustomers2Request) (*CustomerListCustomersResponse, *http.Response, error)

	/*
	CustomerListGroups Method for CustomerListGroups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerListGroupsRequest
	*/
	CustomerListGroups(ctx context.Context) CustomerAPICustomerListGroupsRequest

	// CustomerListGroupsExecute executes the request
	//  @return CustomerListGroupsResponse
	CustomerListGroupsExecute(r CustomerAPICustomerListGroupsRequest) (*CustomerListGroupsResponse, *http.Response, error)

	/*
	CustomerListGroups2 Method for CustomerListGroups2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerListGroups2Request
	*/
	CustomerListGroups2(ctx context.Context) CustomerAPICustomerListGroups2Request

	// CustomerListGroups2Execute executes the request
	//  @return CustomerListGroupsResponse
	CustomerListGroups2Execute(r CustomerAPICustomerListGroups2Request) (*CustomerListGroupsResponse, *http.Response, error)

	/*
	CustomerRemoveCustomerFromGroup Method for CustomerRemoveCustomerFromGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRemoveCustomerFromGroupRequest
	*/
	CustomerRemoveCustomerFromGroup(ctx context.Context) CustomerAPICustomerRemoveCustomerFromGroupRequest

	// CustomerRemoveCustomerFromGroupExecute executes the request
	//  @return CustomerGroupResponse
	CustomerRemoveCustomerFromGroupExecute(r CustomerAPICustomerRemoveCustomerFromGroupRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerRemoveCustomerFromGroup2 Method for CustomerRemoveCustomerFromGroup2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRemoveCustomerFromGroup2Request
	*/
	CustomerRemoveCustomerFromGroup2(ctx context.Context) CustomerAPICustomerRemoveCustomerFromGroup2Request

	// CustomerRemoveCustomerFromGroup2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerRemoveCustomerFromGroup2Execute(r CustomerAPICustomerRemoveCustomerFromGroup2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerRemoveDefaultAddress Method for CustomerRemoveDefaultAddress

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRemoveDefaultAddressRequest
	*/
	CustomerRemoveDefaultAddress(ctx context.Context) CustomerAPICustomerRemoveDefaultAddressRequest

	// CustomerRemoveDefaultAddressExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerRemoveDefaultAddressExecute(r CustomerAPICustomerRemoveDefaultAddressRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerRemoveDefaultAddress2 Method for CustomerRemoveDefaultAddress2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRemoveDefaultAddress2Request
	*/
	CustomerRemoveDefaultAddress2(ctx context.Context) CustomerAPICustomerRemoveDefaultAddress2Request

	// CustomerRemoveDefaultAddress2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerRemoveDefaultAddress2Execute(r CustomerAPICustomerRemoveDefaultAddress2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerRevokePermissions Method for CustomerRevokePermissions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRevokePermissionsRequest
	*/
	CustomerRevokePermissions(ctx context.Context) CustomerAPICustomerRevokePermissionsRequest

	// CustomerRevokePermissionsExecute executes the request
	//  @return map[string]interface{}
	CustomerRevokePermissionsExecute(r CustomerAPICustomerRevokePermissionsRequest) (map[string]interface{}, *http.Response, error)

	/*
	CustomerRevokePermissions2 Method for CustomerRevokePermissions2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerRevokePermissions2Request
	*/
	CustomerRevokePermissions2(ctx context.Context) CustomerAPICustomerRevokePermissions2Request

	// CustomerRevokePermissions2Execute executes the request
	//  @return map[string]interface{}
	CustomerRevokePermissions2Execute(r CustomerAPICustomerRevokePermissions2Request) (map[string]interface{}, *http.Response, error)

	/*
	CustomerSearch Method for CustomerSearch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSearchRequest
	*/
	CustomerSearch(ctx context.Context) CustomerAPICustomerSearchRequest

	// CustomerSearchExecute executes the request
	//  @return CustomerSearchResponse
	CustomerSearchExecute(r CustomerAPICustomerSearchRequest) (*CustomerSearchResponse, *http.Response, error)

	/*
	CustomerSearch2 Method for CustomerSearch2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSearch2Request
	*/
	CustomerSearch2(ctx context.Context) CustomerAPICustomerSearch2Request

	// CustomerSearch2Execute executes the request
	//  @return CustomerSearchResponse
	CustomerSearch2Execute(r CustomerAPICustomerSearch2Request) (*CustomerSearchResponse, *http.Response, error)

	/*
	CustomerSetDefaultAddress Method for CustomerSetDefaultAddress

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSetDefaultAddressRequest
	*/
	CustomerSetDefaultAddress(ctx context.Context) CustomerAPICustomerSetDefaultAddressRequest

	// CustomerSetDefaultAddressExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerSetDefaultAddressExecute(r CustomerAPICustomerSetDefaultAddressRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerSetDefaultAddress2 Method for CustomerSetDefaultAddress2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSetDefaultAddress2Request
	*/
	CustomerSetDefaultAddress2(ctx context.Context) CustomerAPICustomerSetDefaultAddress2Request

	// CustomerSetDefaultAddress2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerSetDefaultAddress2Execute(r CustomerAPICustomerSetDefaultAddress2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerSetPermissions Method for CustomerSetPermissions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSetPermissionsRequest
	*/
	CustomerSetPermissions(ctx context.Context) CustomerAPICustomerSetPermissionsRequest

	// CustomerSetPermissionsExecute executes the request
	//  @return map[string]interface{}
	CustomerSetPermissionsExecute(r CustomerAPICustomerSetPermissionsRequest) (map[string]interface{}, *http.Response, error)

	/*
	CustomerSetPermissions2 Method for CustomerSetPermissions2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerSetPermissions2Request
	*/
	CustomerSetPermissions2(ctx context.Context) CustomerAPICustomerSetPermissions2Request

	// CustomerSetPermissions2Execute executes the request
	//  @return map[string]interface{}
	CustomerSetPermissions2Execute(r CustomerAPICustomerSetPermissions2Request) (map[string]interface{}, *http.Response, error)

	/*
	CustomerUnassignAgent Method for CustomerUnassignAgent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUnassignAgentRequest
	*/
	CustomerUnassignAgent(ctx context.Context) CustomerAPICustomerUnassignAgentRequest

	// CustomerUnassignAgentExecute executes the request
	//  @return map[string]interface{}
	CustomerUnassignAgentExecute(r CustomerAPICustomerUnassignAgentRequest) (map[string]interface{}, *http.Response, error)

	/*
	CustomerUnsubscribe Method for CustomerUnsubscribe

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUnsubscribeRequest
	*/
	CustomerUnsubscribe(ctx context.Context) CustomerAPICustomerUnsubscribeRequest

	// CustomerUnsubscribeExecute executes the request
	//  @return CustomerUnsubscribeResponse
	CustomerUnsubscribeExecute(r CustomerAPICustomerUnsubscribeRequest) (*CustomerUnsubscribeResponse, *http.Response, error)

	/*
	CustomerUnsubscribe2 Method for CustomerUnsubscribe2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUnsubscribe2Request
	*/
	CustomerUnsubscribe2(ctx context.Context) CustomerAPICustomerUnsubscribe2Request

	// CustomerUnsubscribe2Execute executes the request
	//  @return CustomerUnsubscribeResponse
	CustomerUnsubscribe2Execute(r CustomerAPICustomerUnsubscribe2Request) (*CustomerUnsubscribeResponse, *http.Response, error)

	/*
	CustomerUpdate Method for CustomerUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateRequest
	*/
	CustomerUpdate(ctx context.Context) CustomerAPICustomerUpdateRequest

	// CustomerUpdateExecute executes the request
	//  @return CustomerCustomerResponse
	CustomerUpdateExecute(r CustomerAPICustomerUpdateRequest) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerUpdate2 Method for CustomerUpdate2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdate2Request
	*/
	CustomerUpdate2(ctx context.Context) CustomerAPICustomerUpdate2Request

	// CustomerUpdate2Execute executes the request
	//  @return CustomerCustomerResponse
	CustomerUpdate2Execute(r CustomerAPICustomerUpdate2Request) (*CustomerCustomerResponse, *http.Response, error)

	/*
	CustomerUpdateAddress Method for CustomerUpdateAddress

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateAddressRequest
	*/
	CustomerUpdateAddress(ctx context.Context) CustomerAPICustomerUpdateAddressRequest

	// CustomerUpdateAddressExecute executes the request
	//  @return CustomerAddressUpdateResponse
	CustomerUpdateAddressExecute(r CustomerAPICustomerUpdateAddressRequest) (*CustomerAddressUpdateResponse, *http.Response, error)

	/*
	CustomerUpdateAddress2 Method for CustomerUpdateAddress2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateAddress2Request
	*/
	CustomerUpdateAddress2(ctx context.Context) CustomerAPICustomerUpdateAddress2Request

	// CustomerUpdateAddress2Execute executes the request
	//  @return CustomerAddressUpdateResponse
	CustomerUpdateAddress2Execute(r CustomerAPICustomerUpdateAddress2Request) (*CustomerAddressUpdateResponse, *http.Response, error)

	/*
	CustomerUpdateGroup Method for CustomerUpdateGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateGroupRequest
	*/
	CustomerUpdateGroup(ctx context.Context) CustomerAPICustomerUpdateGroupRequest

	// CustomerUpdateGroupExecute executes the request
	//  @return CustomerGroupResponse
	CustomerUpdateGroupExecute(r CustomerAPICustomerUpdateGroupRequest) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerUpdateGroup2 Method for CustomerUpdateGroup2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateGroup2Request
	*/
	CustomerUpdateGroup2(ctx context.Context) CustomerAPICustomerUpdateGroup2Request

	// CustomerUpdateGroup2Execute executes the request
	//  @return CustomerGroupResponse
	CustomerUpdateGroup2Execute(r CustomerAPICustomerUpdateGroup2Request) (*CustomerGroupResponse, *http.Response, error)

	/*
	CustomerUpdateSubscriber Method for CustomerUpdateSubscriber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateSubscriberRequest
	*/
	CustomerUpdateSubscriber(ctx context.Context) CustomerAPICustomerUpdateSubscriberRequest

	// CustomerUpdateSubscriberExecute executes the request
	//  @return CustomerSubscriberResponse
	CustomerUpdateSubscriberExecute(r CustomerAPICustomerUpdateSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error)

	/*
	CustomerUpdateSubscriber2 Method for CustomerUpdateSubscriber2

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CustomerAPICustomerUpdateSubscriber2Request
	*/
	CustomerUpdateSubscriber2(ctx context.Context) CustomerAPICustomerUpdateSubscriber2Request

	// CustomerUpdateSubscriber2Execute executes the request
	//  @return CustomerSubscriberResponse
	CustomerUpdateSubscriber2Execute(r CustomerAPICustomerUpdateSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error)
}

// CustomerAPIService CustomerAPI service
type CustomerAPIService service

type CustomerAPICustomerAcquireSubscriberRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateSubscriberRequest
}

func (r CustomerAPICustomerAcquireSubscriberRequest) Body(body CustomerCreateSubscriberRequest) CustomerAPICustomerAcquireSubscriberRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAcquireSubscriberRequest) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerAcquireSubscriberExecute(r)
}

/*
CustomerAcquireSubscriber Method for CustomerAcquireSubscriber

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAcquireSubscriberRequest
*/
func (a *CustomerAPIService) CustomerAcquireSubscriber(ctx context.Context) CustomerAPICustomerAcquireSubscriberRequest {
	return CustomerAPICustomerAcquireSubscriberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerAcquireSubscriberExecute(r CustomerAPICustomerAcquireSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAcquireSubscriber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/acquire_subscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAcquireSubscriber2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateSubscriberRequest
}

func (r CustomerAPICustomerAcquireSubscriber2Request) Body(body CustomerCreateSubscriberRequest) CustomerAPICustomerAcquireSubscriber2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAcquireSubscriber2Request) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerAcquireSubscriber2Execute(r)
}

/*
CustomerAcquireSubscriber2 Method for CustomerAcquireSubscriber2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAcquireSubscriber2Request
*/
func (a *CustomerAPIService) CustomerAcquireSubscriber2(ctx context.Context) CustomerAPICustomerAcquireSubscriber2Request {
	return CustomerAPICustomerAcquireSubscriber2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerAcquireSubscriber2Execute(r CustomerAPICustomerAcquireSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAcquireSubscriber2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/AcquireSubscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAcquireUnsubscriberRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUnsubscribeRequest
}

func (r CustomerAPICustomerAcquireUnsubscriberRequest) Body(body CustomerUnsubscribeRequest) CustomerAPICustomerAcquireUnsubscriberRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAcquireUnsubscriberRequest) Execute() (*CustomerUnsubscribeResponse, *http.Response, error) {
	return r.ApiService.CustomerAcquireUnsubscriberExecute(r)
}

/*
CustomerAcquireUnsubscriber Method for CustomerAcquireUnsubscriber

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAcquireUnsubscriberRequest
*/
func (a *CustomerAPIService) CustomerAcquireUnsubscriber(ctx context.Context) CustomerAPICustomerAcquireUnsubscriberRequest {
	return CustomerAPICustomerAcquireUnsubscriberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerUnsubscribeResponse
func (a *CustomerAPIService) CustomerAcquireUnsubscriberExecute(r CustomerAPICustomerAcquireUnsubscriberRequest) (*CustomerUnsubscribeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerUnsubscribeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAcquireUnsubscriber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/acquire_unsubscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAcquireUnsubscriber2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUnsubscribeRequest
}

func (r CustomerAPICustomerAcquireUnsubscriber2Request) Body(body CustomerUnsubscribeRequest) CustomerAPICustomerAcquireUnsubscriber2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAcquireUnsubscriber2Request) Execute() (*CustomerUnsubscribeResponse, *http.Response, error) {
	return r.ApiService.CustomerAcquireUnsubscriber2Execute(r)
}

/*
CustomerAcquireUnsubscriber2 Method for CustomerAcquireUnsubscriber2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAcquireUnsubscriber2Request
*/
func (a *CustomerAPIService) CustomerAcquireUnsubscriber2(ctx context.Context) CustomerAPICustomerAcquireUnsubscriber2Request {
	return CustomerAPICustomerAcquireUnsubscriber2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerUnsubscribeResponse
func (a *CustomerAPIService) CustomerAcquireUnsubscriber2Execute(r CustomerAPICustomerAcquireUnsubscriber2Request) (*CustomerUnsubscribeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerUnsubscribeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAcquireUnsubscriber2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/AcquireUnsubscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAddCustomerToGroupRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddCustomerToGroupRequest
}

func (r CustomerAPICustomerAddCustomerToGroupRequest) Body(body CustomerAddCustomerToGroupRequest) CustomerAPICustomerAddCustomerToGroupRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAddCustomerToGroupRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerAddCustomerToGroupExecute(r)
}

/*
CustomerAddCustomerToGroup Method for CustomerAddCustomerToGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAddCustomerToGroupRequest
*/
func (a *CustomerAPIService) CustomerAddCustomerToGroup(ctx context.Context) CustomerAPICustomerAddCustomerToGroupRequest {
	return CustomerAPICustomerAddCustomerToGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerAddCustomerToGroupExecute(r CustomerAPICustomerAddCustomerToGroupRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAddCustomerToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/add_customer_to_segment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAddCustomerToGroup2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddCustomerToGroupRequest
}

func (r CustomerAPICustomerAddCustomerToGroup2Request) Body(body CustomerAddCustomerToGroupRequest) CustomerAPICustomerAddCustomerToGroup2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAddCustomerToGroup2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerAddCustomerToGroup2Execute(r)
}

/*
CustomerAddCustomerToGroup2 Method for CustomerAddCustomerToGroup2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAddCustomerToGroup2Request
*/
func (a *CustomerAPIService) CustomerAddCustomerToGroup2(ctx context.Context) CustomerAPICustomerAddCustomerToGroup2Request {
	return CustomerAPICustomerAddCustomerToGroup2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerAddCustomerToGroup2Execute(r CustomerAPICustomerAddCustomerToGroup2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAddCustomerToGroup2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/AddCustomerToGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerAssignAgentRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAssignAgentRequest
}

func (r CustomerAPICustomerAssignAgentRequest) Body(body CustomerAssignAgentRequest) CustomerAPICustomerAssignAgentRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerAssignAgentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerAssignAgentExecute(r)
}

/*
CustomerAssignAgent Method for CustomerAssignAgent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerAssignAgentRequest
*/
func (a *CustomerAPIService) CustomerAssignAgent(ctx context.Context) CustomerAPICustomerAssignAgentRequest {
	return CustomerAPICustomerAssignAgentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerAssignAgentExecute(r CustomerAPICustomerAssignAgentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerAssignAgent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/AssignAgent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerBulkUpdateRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerBulkUpdateRequest
}

func (r CustomerAPICustomerBulkUpdateRequest) Body(body CustomerBulkUpdateRequest) CustomerAPICustomerBulkUpdateRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerBulkUpdateRequest) Execute() (*CustomerBulkUpdateResponse, *http.Response, error) {
	return r.ApiService.CustomerBulkUpdateExecute(r)
}

/*
CustomerBulkUpdate Method for CustomerBulkUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerBulkUpdateRequest
*/
func (a *CustomerAPIService) CustomerBulkUpdate(ctx context.Context) CustomerAPICustomerBulkUpdateRequest {
	return CustomerAPICustomerBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerBulkUpdateResponse
func (a *CustomerAPIService) CustomerBulkUpdateExecute(r CustomerAPICustomerBulkUpdateRequest) (*CustomerBulkUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerBulkUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/bulk_update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerBulkUpdate2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerBulkUpdateRequest
}

func (r CustomerAPICustomerBulkUpdate2Request) Body(body CustomerBulkUpdateRequest) CustomerAPICustomerBulkUpdate2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerBulkUpdate2Request) Execute() (*CustomerBulkUpdateResponse, *http.Response, error) {
	return r.ApiService.CustomerBulkUpdate2Execute(r)
}

/*
CustomerBulkUpdate2 Method for CustomerBulkUpdate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerBulkUpdate2Request
*/
func (a *CustomerAPIService) CustomerBulkUpdate2(ctx context.Context) CustomerAPICustomerBulkUpdate2Request {
	return CustomerAPICustomerBulkUpdate2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerBulkUpdateResponse
func (a *CustomerAPIService) CustomerBulkUpdate2Execute(r CustomerAPICustomerBulkUpdate2Request) (*CustomerBulkUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerBulkUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerBulkUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/BulkUpdate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateRequest
}

func (r CustomerAPICustomerCreateRequest) Body(body CustomerCreateRequest) CustomerAPICustomerCreateRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateExecute(r)
}

/*
CustomerCreate Method for CustomerCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateRequest
*/
func (a *CustomerAPIService) CustomerCreate(ctx context.Context) CustomerAPICustomerCreateRequest {
	return CustomerAPICustomerCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerCreateExecute(r CustomerAPICustomerCreateRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreate2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateRequest
}

func (r CustomerAPICustomerCreate2Request) Body(body CustomerCreateRequest) CustomerAPICustomerCreate2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreate2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerCreate2Execute(r)
}

/*
CustomerCreate2 Method for CustomerCreate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreate2Request
*/
func (a *CustomerAPIService) CustomerCreate2(ctx context.Context) CustomerAPICustomerCreate2Request {
	return CustomerAPICustomerCreate2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerCreate2Execute(r CustomerAPICustomerCreate2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/Create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateAddressRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressCreateRequest
}

func (r CustomerAPICustomerCreateAddressRequest) Body(body CustomerAddressCreateRequest) CustomerAPICustomerCreateAddressRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateAddressRequest) Execute() (*CustomerAddressCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateAddressExecute(r)
}

/*
CustomerCreateAddress Method for CustomerCreateAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateAddressRequest
*/
func (a *CustomerAPIService) CustomerCreateAddress(ctx context.Context) CustomerAPICustomerCreateAddressRequest {
	return CustomerAPICustomerCreateAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressCustomerResponse
func (a *CustomerAPIService) CustomerCreateAddressExecute(r CustomerAPICustomerCreateAddressRequest) (*CustomerAddressCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/create_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateAddress2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressCreateRequest
}

func (r CustomerAPICustomerCreateAddress2Request) Body(body CustomerAddressCreateRequest) CustomerAPICustomerCreateAddress2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateAddress2Request) Execute() (*CustomerAddressCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateAddress2Execute(r)
}

/*
CustomerCreateAddress2 Method for CustomerCreateAddress2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateAddress2Request
*/
func (a *CustomerAPIService) CustomerCreateAddress2(ctx context.Context) CustomerAPICustomerCreateAddress2Request {
	return CustomerAPICustomerCreateAddress2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressCustomerResponse
func (a *CustomerAPIService) CustomerCreateAddress2Execute(r CustomerAPICustomerCreateAddress2Request) (*CustomerAddressCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateAddress2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/CreateAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateGroupRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateGroupRequest
}

func (r CustomerAPICustomerCreateGroupRequest) Body(body CustomerCreateGroupRequest) CustomerAPICustomerCreateGroupRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateGroupRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateGroupExecute(r)
}

/*
CustomerCreateGroup Method for CustomerCreateGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateGroupRequest
*/
func (a *CustomerAPIService) CustomerCreateGroup(ctx context.Context) CustomerAPICustomerCreateGroupRequest {
	return CustomerAPICustomerCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerCreateGroupExecute(r CustomerAPICustomerCreateGroupRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/create_segment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateGroup2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateGroupRequest
}

func (r CustomerAPICustomerCreateGroup2Request) Body(body CustomerCreateGroupRequest) CustomerAPICustomerCreateGroup2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateGroup2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateGroup2Execute(r)
}

/*
CustomerCreateGroup2 Method for CustomerCreateGroup2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateGroup2Request
*/
func (a *CustomerAPIService) CustomerCreateGroup2(ctx context.Context) CustomerAPICustomerCreateGroup2Request {
	return CustomerAPICustomerCreateGroup2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerCreateGroup2Execute(r CustomerAPICustomerCreateGroup2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateGroup2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/CreateGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateSubscriberRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateSubscriberRequest
}

func (r CustomerAPICustomerCreateSubscriberRequest) Body(body CustomerCreateSubscriberRequest) CustomerAPICustomerCreateSubscriberRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateSubscriberRequest) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateSubscriberExecute(r)
}

/*
CustomerCreateSubscriber Method for CustomerCreateSubscriber

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateSubscriberRequest
*/
func (a *CustomerAPIService) CustomerCreateSubscriber(ctx context.Context) CustomerAPICustomerCreateSubscriberRequest {
	return CustomerAPICustomerCreateSubscriberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerCreateSubscriberExecute(r CustomerAPICustomerCreateSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateSubscriber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/create_subscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerCreateSubscriber2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerCreateSubscriberRequest
}

func (r CustomerAPICustomerCreateSubscriber2Request) Body(body CustomerCreateSubscriberRequest) CustomerAPICustomerCreateSubscriber2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerCreateSubscriber2Request) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerCreateSubscriber2Execute(r)
}

/*
CustomerCreateSubscriber2 Method for CustomerCreateSubscriber2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerCreateSubscriber2Request
*/
func (a *CustomerAPIService) CustomerCreateSubscriber2(ctx context.Context) CustomerAPICustomerCreateSubscriber2Request {
	return CustomerAPICustomerCreateSubscriber2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerCreateSubscriber2Execute(r CustomerAPICustomerCreateSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerCreateSubscriber2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/CreateSubscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerDeleteAddressRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressDeleteRequest
}

func (r CustomerAPICustomerDeleteAddressRequest) Body(body CustomerAddressDeleteRequest) CustomerAPICustomerDeleteAddressRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerDeleteAddressRequest) Execute() (*CustomerAddressDeleteResponse, *http.Response, error) {
	return r.ApiService.CustomerDeleteAddressExecute(r)
}

/*
CustomerDeleteAddress Method for CustomerDeleteAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerDeleteAddressRequest
*/
func (a *CustomerAPIService) CustomerDeleteAddress(ctx context.Context) CustomerAPICustomerDeleteAddressRequest {
	return CustomerAPICustomerDeleteAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressDeleteResponse
func (a *CustomerAPIService) CustomerDeleteAddressExecute(r CustomerAPICustomerDeleteAddressRequest) (*CustomerAddressDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerDeleteAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/delete_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerDeleteAddress2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressDeleteRequest
}

func (r CustomerAPICustomerDeleteAddress2Request) Body(body CustomerAddressDeleteRequest) CustomerAPICustomerDeleteAddress2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerDeleteAddress2Request) Execute() (*CustomerAddressDeleteResponse, *http.Response, error) {
	return r.ApiService.CustomerDeleteAddress2Execute(r)
}

/*
CustomerDeleteAddress2 Method for CustomerDeleteAddress2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerDeleteAddress2Request
*/
func (a *CustomerAPIService) CustomerDeleteAddress2(ctx context.Context) CustomerAPICustomerDeleteAddress2Request {
	return CustomerAPICustomerDeleteAddress2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressDeleteResponse
func (a *CustomerAPIService) CustomerDeleteAddress2Execute(r CustomerAPICustomerDeleteAddress2Request) (*CustomerAddressDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerDeleteAddress2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/DeleteAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerDeleteGroupRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerDeleteGroupRequest
}

func (r CustomerAPICustomerDeleteGroupRequest) Body(body CustomerDeleteGroupRequest) CustomerAPICustomerDeleteGroupRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerDeleteGroupRequest) Execute() (*CustomerDeleteGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerDeleteGroupExecute(r)
}

/*
CustomerDeleteGroup Method for CustomerDeleteGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerDeleteGroupRequest
*/
func (a *CustomerAPIService) CustomerDeleteGroup(ctx context.Context) CustomerAPICustomerDeleteGroupRequest {
	return CustomerAPICustomerDeleteGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerDeleteGroupResponse
func (a *CustomerAPIService) CustomerDeleteGroupExecute(r CustomerAPICustomerDeleteGroupRequest) (*CustomerDeleteGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerDeleteGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerDeleteGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/delete_segment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerDeleteGroup2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerDeleteGroupRequest
}

func (r CustomerAPICustomerDeleteGroup2Request) Body(body CustomerDeleteGroupRequest) CustomerAPICustomerDeleteGroup2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerDeleteGroup2Request) Execute() (*CustomerDeleteGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerDeleteGroup2Execute(r)
}

/*
CustomerDeleteGroup2 Method for CustomerDeleteGroup2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerDeleteGroup2Request
*/
func (a *CustomerAPIService) CustomerDeleteGroup2(ctx context.Context) CustomerAPICustomerDeleteGroup2Request {
	return CustomerAPICustomerDeleteGroup2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerDeleteGroupResponse
func (a *CustomerAPIService) CustomerDeleteGroup2Execute(r CustomerAPICustomerDeleteGroup2Request) (*CustomerDeleteGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerDeleteGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerDeleteGroup2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/DeleteGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindManyRequest
}

func (r CustomerAPICustomerFindRequest) Body(body CustomerFindManyRequest) CustomerAPICustomerFindRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindRequest) Execute() (*CustomerFindManyResponse, *http.Response, error) {
	return r.ApiService.CustomerFindExecute(r)
}

/*
CustomerFind Method for CustomerFind

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindRequest
*/
func (a *CustomerAPIService) CustomerFind(ctx context.Context) CustomerAPICustomerFindRequest {
	return CustomerAPICustomerFindRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerFindManyResponse
func (a *CustomerAPIService) CustomerFindExecute(r CustomerAPICustomerFindRequest) (*CustomerFindManyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerFindManyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/find"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFind2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindManyRequest
}

func (r CustomerAPICustomerFind2Request) Body(body CustomerFindManyRequest) CustomerAPICustomerFind2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFind2Request) Execute() (*CustomerFindManyResponse, *http.Response, error) {
	return r.ApiService.CustomerFind2Execute(r)
}

/*
CustomerFind2 Method for CustomerFind2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFind2Request
*/
func (a *CustomerAPIService) CustomerFind2(ctx context.Context) CustomerAPICustomerFind2Request {
	return CustomerAPICustomerFind2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerFindManyResponse
func (a *CustomerAPIService) CustomerFind2Execute(r CustomerAPICustomerFind2Request) (*CustomerFindManyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerFindManyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFind2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/Find"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindByEmailRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindByEmailRequest
}

func (r CustomerAPICustomerFindByEmailRequest) Body(body CustomerFindByEmailRequest) CustomerAPICustomerFindByEmailRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindByEmailRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerFindByEmailExecute(r)
}

/*
CustomerFindByEmail Method for CustomerFindByEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindByEmailRequest
*/
func (a *CustomerAPIService) CustomerFindByEmail(ctx context.Context) CustomerAPICustomerFindByEmailRequest {
	return CustomerAPICustomerFindByEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerFindByEmailExecute(r CustomerAPICustomerFindByEmailRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/find_by_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindByEmail2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindByEmailRequest
}

func (r CustomerAPICustomerFindByEmail2Request) Body(body CustomerFindByEmailRequest) CustomerAPICustomerFindByEmail2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindByEmail2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerFindByEmail2Execute(r)
}

/*
CustomerFindByEmail2 Method for CustomerFindByEmail2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindByEmail2Request
*/
func (a *CustomerAPIService) CustomerFindByEmail2(ctx context.Context) CustomerAPICustomerFindByEmail2Request {
	return CustomerAPICustomerFindByEmail2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerFindByEmail2Execute(r CustomerAPICustomerFindByEmail2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindByEmail2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/FindByEmail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindByIdRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindByIdRequest
}

func (r CustomerAPICustomerFindByIdRequest) Body(body CustomerFindByIdRequest) CustomerAPICustomerFindByIdRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindByIdRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerFindByIdExecute(r)
}

/*
CustomerFindById Method for CustomerFindById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindByIdRequest
*/
func (a *CustomerAPIService) CustomerFindById(ctx context.Context) CustomerAPICustomerFindByIdRequest {
	return CustomerAPICustomerFindByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerFindByIdExecute(r CustomerAPICustomerFindByIdRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/find_by_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindById2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindByIdRequest
}

func (r CustomerAPICustomerFindById2Request) Body(body CustomerFindByIdRequest) CustomerAPICustomerFindById2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindById2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerFindById2Execute(r)
}

/*
CustomerFindById2 Method for CustomerFindById2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindById2Request
*/
func (a *CustomerAPIService) CustomerFindById2(ctx context.Context) CustomerAPICustomerFindById2Request {
	return CustomerAPICustomerFindById2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerFindById2Execute(r CustomerAPICustomerFindById2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindById2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/FindById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindSubscriberByEmailRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindSubscriberByEmailRequest
}

func (r CustomerAPICustomerFindSubscriberByEmailRequest) Body(body CustomerFindSubscriberByEmailRequest) CustomerAPICustomerFindSubscriberByEmailRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindSubscriberByEmailRequest) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerFindSubscriberByEmailExecute(r)
}

/*
CustomerFindSubscriberByEmail Method for CustomerFindSubscriberByEmail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindSubscriberByEmailRequest
*/
func (a *CustomerAPIService) CustomerFindSubscriberByEmail(ctx context.Context) CustomerAPICustomerFindSubscriberByEmailRequest {
	return CustomerAPICustomerFindSubscriberByEmailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerFindSubscriberByEmailExecute(r CustomerAPICustomerFindSubscriberByEmailRequest) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindSubscriberByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/find_subscriber_by_email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindSubscriberByEmail2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindSubscriberByEmailRequest
}

func (r CustomerAPICustomerFindSubscriberByEmail2Request) Body(body CustomerFindSubscriberByEmailRequest) CustomerAPICustomerFindSubscriberByEmail2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindSubscriberByEmail2Request) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerFindSubscriberByEmail2Execute(r)
}

/*
CustomerFindSubscriberByEmail2 Method for CustomerFindSubscriberByEmail2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindSubscriberByEmail2Request
*/
func (a *CustomerAPIService) CustomerFindSubscriberByEmail2(ctx context.Context) CustomerAPICustomerFindSubscriberByEmail2Request {
	return CustomerAPICustomerFindSubscriberByEmail2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerFindSubscriberByEmail2Execute(r CustomerAPICustomerFindSubscriberByEmail2Request) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindSubscriberByEmail2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/FindSubscriberByEmail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindSubscriberByIdRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindSubscriberByIdRequest
}

func (r CustomerAPICustomerFindSubscriberByIdRequest) Body(body CustomerFindSubscriberByIdRequest) CustomerAPICustomerFindSubscriberByIdRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindSubscriberByIdRequest) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerFindSubscriberByIdExecute(r)
}

/*
CustomerFindSubscriberById Method for CustomerFindSubscriberById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindSubscriberByIdRequest
*/
func (a *CustomerAPIService) CustomerFindSubscriberById(ctx context.Context) CustomerAPICustomerFindSubscriberByIdRequest {
	return CustomerAPICustomerFindSubscriberByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerFindSubscriberByIdExecute(r CustomerAPICustomerFindSubscriberByIdRequest) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindSubscriberById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/find_subscriber_by_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerFindSubscriberById2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerFindSubscriberByIdRequest
}

func (r CustomerAPICustomerFindSubscriberById2Request) Body(body CustomerFindSubscriberByIdRequest) CustomerAPICustomerFindSubscriberById2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerFindSubscriberById2Request) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerFindSubscriberById2Execute(r)
}

/*
CustomerFindSubscriberById2 Method for CustomerFindSubscriberById2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerFindSubscriberById2Request
*/
func (a *CustomerAPIService) CustomerFindSubscriberById2(ctx context.Context) CustomerAPICustomerFindSubscriberById2Request {
	return CustomerAPICustomerFindSubscriberById2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerFindSubscriberById2Execute(r CustomerAPICustomerFindSubscriberById2Request) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerFindSubscriberById2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/FindSubscriberById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGetGroupByCodeRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGetGroupByCodeRequest
}

func (r CustomerAPICustomerGetGroupByCodeRequest) Body(body CustomerGetGroupByCodeRequest) CustomerAPICustomerGetGroupByCodeRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGetGroupByCodeRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerGetGroupByCodeExecute(r)
}

/*
CustomerGetGroupByCode Method for CustomerGetGroupByCode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGetGroupByCodeRequest
*/
func (a *CustomerAPIService) CustomerGetGroupByCode(ctx context.Context) CustomerAPICustomerGetGroupByCodeRequest {
	return CustomerAPICustomerGetGroupByCodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerGetGroupByCodeExecute(r CustomerAPICustomerGetGroupByCodeRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGetGroupByCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/get_segment_by_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGetGroupByCode2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGetGroupByCodeRequest
}

func (r CustomerAPICustomerGetGroupByCode2Request) Body(body CustomerGetGroupByCodeRequest) CustomerAPICustomerGetGroupByCode2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGetGroupByCode2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerGetGroupByCode2Execute(r)
}

/*
CustomerGetGroupByCode2 Method for CustomerGetGroupByCode2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGetGroupByCode2Request
*/
func (a *CustomerAPIService) CustomerGetGroupByCode2(ctx context.Context) CustomerAPICustomerGetGroupByCode2Request {
	return CustomerAPICustomerGetGroupByCode2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerGetGroupByCode2Execute(r CustomerAPICustomerGetGroupByCode2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGetGroupByCode2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/GetGroupByCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGetGroupByIdRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGetGroupByIdRequest
}

func (r CustomerAPICustomerGetGroupByIdRequest) Body(body CustomerGetGroupByIdRequest) CustomerAPICustomerGetGroupByIdRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGetGroupByIdRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerGetGroupByIdExecute(r)
}

/*
CustomerGetGroupById Method for CustomerGetGroupById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGetGroupByIdRequest
*/
func (a *CustomerAPIService) CustomerGetGroupById(ctx context.Context) CustomerAPICustomerGetGroupByIdRequest {
	return CustomerAPICustomerGetGroupByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerGetGroupByIdExecute(r CustomerAPICustomerGetGroupByIdRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGetGroupById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/get_segment_by_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGetGroupById2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGetGroupByIdRequest
}

func (r CustomerAPICustomerGetGroupById2Request) Body(body CustomerGetGroupByIdRequest) CustomerAPICustomerGetGroupById2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGetGroupById2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerGetGroupById2Execute(r)
}

/*
CustomerGetGroupById2 Method for CustomerGetGroupById2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGetGroupById2Request
*/
func (a *CustomerAPIService) CustomerGetGroupById2(ctx context.Context) CustomerAPICustomerGetGroupById2Request {
	return CustomerAPICustomerGetGroupById2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerGetGroupById2Execute(r CustomerAPICustomerGetGroupById2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGetGroupById2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/GetGroupById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGrantPermissionsRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGrantPermissionsRequest
}

func (r CustomerAPICustomerGrantPermissionsRequest) Body(body CustomerGrantPermissionsRequest) CustomerAPICustomerGrantPermissionsRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGrantPermissionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerGrantPermissionsExecute(r)
}

/*
CustomerGrantPermissions Method for CustomerGrantPermissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGrantPermissionsRequest
*/
func (a *CustomerAPIService) CustomerGrantPermissions(ctx context.Context) CustomerAPICustomerGrantPermissionsRequest {
	return CustomerAPICustomerGrantPermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerGrantPermissionsExecute(r CustomerAPICustomerGrantPermissionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGrantPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/grant_permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerGrantPermissions2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerGrantPermissionsRequest
}

func (r CustomerAPICustomerGrantPermissions2Request) Body(body CustomerGrantPermissionsRequest) CustomerAPICustomerGrantPermissions2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerGrantPermissions2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerGrantPermissions2Execute(r)
}

/*
CustomerGrantPermissions2 Method for CustomerGrantPermissions2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerGrantPermissions2Request
*/
func (a *CustomerAPIService) CustomerGrantPermissions2(ctx context.Context) CustomerAPICustomerGrantPermissions2Request {
	return CustomerAPICustomerGrantPermissions2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerGrantPermissions2Execute(r CustomerAPICustomerGrantPermissions2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerGrantPermissions2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/GrantPermissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerListConsentsRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerListConsentsRequest
}

func (r CustomerAPICustomerListConsentsRequest) Body(body CustomerListConsentsRequest) CustomerAPICustomerListConsentsRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerListConsentsRequest) Execute() (*CustomerListConsentsResponse, *http.Response, error) {
	return r.ApiService.CustomerListConsentsExecute(r)
}

/*
CustomerListConsents ListConsents list all consents of a customer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerListConsentsRequest
*/
func (a *CustomerAPIService) CustomerListConsents(ctx context.Context) CustomerAPICustomerListConsentsRequest {
	return CustomerAPICustomerListConsentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerListConsentsResponse
func (a *CustomerAPIService) CustomerListConsentsExecute(r CustomerAPICustomerListConsentsRequest) (*CustomerListConsentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerListConsentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerListConsents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/ListConsents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerListCustomersRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerListCustomersRequest
}

func (r CustomerAPICustomerListCustomersRequest) Body(body CustomerListCustomersRequest) CustomerAPICustomerListCustomersRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerListCustomersRequest) Execute() (*CustomerListCustomersResponse, *http.Response, error) {
	return r.ApiService.CustomerListCustomersExecute(r)
}

/*
CustomerListCustomers Method for CustomerListCustomers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerListCustomersRequest
*/
func (a *CustomerAPIService) CustomerListCustomers(ctx context.Context) CustomerAPICustomerListCustomersRequest {
	return CustomerAPICustomerListCustomersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerListCustomersResponse
func (a *CustomerAPIService) CustomerListCustomersExecute(r CustomerAPICustomerListCustomersRequest) (*CustomerListCustomersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerListCustomersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerListCustomers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/list_customers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerListCustomers2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerListCustomersRequest
}

func (r CustomerAPICustomerListCustomers2Request) Body(body CustomerListCustomersRequest) CustomerAPICustomerListCustomers2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerListCustomers2Request) Execute() (*CustomerListCustomersResponse, *http.Response, error) {
	return r.ApiService.CustomerListCustomers2Execute(r)
}

/*
CustomerListCustomers2 Method for CustomerListCustomers2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerListCustomers2Request
*/
func (a *CustomerAPIService) CustomerListCustomers2(ctx context.Context) CustomerAPICustomerListCustomers2Request {
	return CustomerAPICustomerListCustomers2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerListCustomersResponse
func (a *CustomerAPIService) CustomerListCustomers2Execute(r CustomerAPICustomerListCustomers2Request) (*CustomerListCustomersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerListCustomersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerListCustomers2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/ListCustomers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerListGroupsRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerListGroupsRequest
}

func (r CustomerAPICustomerListGroupsRequest) Body(body CustomerListGroupsRequest) CustomerAPICustomerListGroupsRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerListGroupsRequest) Execute() (*CustomerListGroupsResponse, *http.Response, error) {
	return r.ApiService.CustomerListGroupsExecute(r)
}

/*
CustomerListGroups Method for CustomerListGroups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerListGroupsRequest
*/
func (a *CustomerAPIService) CustomerListGroups(ctx context.Context) CustomerAPICustomerListGroupsRequest {
	return CustomerAPICustomerListGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerListGroupsResponse
func (a *CustomerAPIService) CustomerListGroupsExecute(r CustomerAPICustomerListGroupsRequest) (*CustomerListGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerListGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerListGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/list_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerListGroups2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerListGroupsRequest
}

func (r CustomerAPICustomerListGroups2Request) Body(body CustomerListGroupsRequest) CustomerAPICustomerListGroups2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerListGroups2Request) Execute() (*CustomerListGroupsResponse, *http.Response, error) {
	return r.ApiService.CustomerListGroups2Execute(r)
}

/*
CustomerListGroups2 Method for CustomerListGroups2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerListGroups2Request
*/
func (a *CustomerAPIService) CustomerListGroups2(ctx context.Context) CustomerAPICustomerListGroups2Request {
	return CustomerAPICustomerListGroups2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerListGroupsResponse
func (a *CustomerAPIService) CustomerListGroups2Execute(r CustomerAPICustomerListGroups2Request) (*CustomerListGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerListGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerListGroups2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/ListGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRemoveCustomerFromGroupRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRemoveCustomerFromGroupRequest
}

func (r CustomerAPICustomerRemoveCustomerFromGroupRequest) Body(body CustomerRemoveCustomerFromGroupRequest) CustomerAPICustomerRemoveCustomerFromGroupRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRemoveCustomerFromGroupRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerRemoveCustomerFromGroupExecute(r)
}

/*
CustomerRemoveCustomerFromGroup Method for CustomerRemoveCustomerFromGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRemoveCustomerFromGroupRequest
*/
func (a *CustomerAPIService) CustomerRemoveCustomerFromGroup(ctx context.Context) CustomerAPICustomerRemoveCustomerFromGroupRequest {
	return CustomerAPICustomerRemoveCustomerFromGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerRemoveCustomerFromGroupExecute(r CustomerAPICustomerRemoveCustomerFromGroupRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRemoveCustomerFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/remove_customer_from_segment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRemoveCustomerFromGroup2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRemoveCustomerFromGroupRequest
}

func (r CustomerAPICustomerRemoveCustomerFromGroup2Request) Body(body CustomerRemoveCustomerFromGroupRequest) CustomerAPICustomerRemoveCustomerFromGroup2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRemoveCustomerFromGroup2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerRemoveCustomerFromGroup2Execute(r)
}

/*
CustomerRemoveCustomerFromGroup2 Method for CustomerRemoveCustomerFromGroup2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRemoveCustomerFromGroup2Request
*/
func (a *CustomerAPIService) CustomerRemoveCustomerFromGroup2(ctx context.Context) CustomerAPICustomerRemoveCustomerFromGroup2Request {
	return CustomerAPICustomerRemoveCustomerFromGroup2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerRemoveCustomerFromGroup2Execute(r CustomerAPICustomerRemoveCustomerFromGroup2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRemoveCustomerFromGroup2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/RemoveCustomerFromGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRemoveDefaultAddressRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRemoveDefaultAddressRequest
}

func (r CustomerAPICustomerRemoveDefaultAddressRequest) Body(body CustomerRemoveDefaultAddressRequest) CustomerAPICustomerRemoveDefaultAddressRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRemoveDefaultAddressRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerRemoveDefaultAddressExecute(r)
}

/*
CustomerRemoveDefaultAddress Method for CustomerRemoveDefaultAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRemoveDefaultAddressRequest
*/
func (a *CustomerAPIService) CustomerRemoveDefaultAddress(ctx context.Context) CustomerAPICustomerRemoveDefaultAddressRequest {
	return CustomerAPICustomerRemoveDefaultAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerRemoveDefaultAddressExecute(r CustomerAPICustomerRemoveDefaultAddressRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRemoveDefaultAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/remove_default_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRemoveDefaultAddress2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRemoveDefaultAddressRequest
}

func (r CustomerAPICustomerRemoveDefaultAddress2Request) Body(body CustomerRemoveDefaultAddressRequest) CustomerAPICustomerRemoveDefaultAddress2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRemoveDefaultAddress2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerRemoveDefaultAddress2Execute(r)
}

/*
CustomerRemoveDefaultAddress2 Method for CustomerRemoveDefaultAddress2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRemoveDefaultAddress2Request
*/
func (a *CustomerAPIService) CustomerRemoveDefaultAddress2(ctx context.Context) CustomerAPICustomerRemoveDefaultAddress2Request {
	return CustomerAPICustomerRemoveDefaultAddress2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerRemoveDefaultAddress2Execute(r CustomerAPICustomerRemoveDefaultAddress2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRemoveDefaultAddress2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/RemoveDefaultAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRevokePermissionsRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRevokePermissionsRequest
}

func (r CustomerAPICustomerRevokePermissionsRequest) Body(body CustomerRevokePermissionsRequest) CustomerAPICustomerRevokePermissionsRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRevokePermissionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerRevokePermissionsExecute(r)
}

/*
CustomerRevokePermissions Method for CustomerRevokePermissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRevokePermissionsRequest
*/
func (a *CustomerAPIService) CustomerRevokePermissions(ctx context.Context) CustomerAPICustomerRevokePermissionsRequest {
	return CustomerAPICustomerRevokePermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerRevokePermissionsExecute(r CustomerAPICustomerRevokePermissionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRevokePermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/revoke_permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerRevokePermissions2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerRevokePermissionsRequest
}

func (r CustomerAPICustomerRevokePermissions2Request) Body(body CustomerRevokePermissionsRequest) CustomerAPICustomerRevokePermissions2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerRevokePermissions2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerRevokePermissions2Execute(r)
}

/*
CustomerRevokePermissions2 Method for CustomerRevokePermissions2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerRevokePermissions2Request
*/
func (a *CustomerAPIService) CustomerRevokePermissions2(ctx context.Context) CustomerAPICustomerRevokePermissions2Request {
	return CustomerAPICustomerRevokePermissions2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerRevokePermissions2Execute(r CustomerAPICustomerRevokePermissions2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerRevokePermissions2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/RevokePermissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSearchRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSearchRequest
}

func (r CustomerAPICustomerSearchRequest) Body(body CustomerSearchRequest) CustomerAPICustomerSearchRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSearchRequest) Execute() (*CustomerSearchResponse, *http.Response, error) {
	return r.ApiService.CustomerSearchExecute(r)
}

/*
CustomerSearch Method for CustomerSearch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSearchRequest
*/
func (a *CustomerAPIService) CustomerSearch(ctx context.Context) CustomerAPICustomerSearchRequest {
	return CustomerAPICustomerSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSearchResponse
func (a *CustomerAPIService) CustomerSearchExecute(r CustomerAPICustomerSearchRequest) (*CustomerSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSearch2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSearchRequest
}

func (r CustomerAPICustomerSearch2Request) Body(body CustomerSearchRequest) CustomerAPICustomerSearch2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSearch2Request) Execute() (*CustomerSearchResponse, *http.Response, error) {
	return r.ApiService.CustomerSearch2Execute(r)
}

/*
CustomerSearch2 Method for CustomerSearch2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSearch2Request
*/
func (a *CustomerAPIService) CustomerSearch2(ctx context.Context) CustomerAPICustomerSearch2Request {
	return CustomerAPICustomerSearch2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSearchResponse
func (a *CustomerAPIService) CustomerSearch2Execute(r CustomerAPICustomerSearch2Request) (*CustomerSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSearch2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/Search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSetDefaultAddressRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSetDefaultAddressRequest
}

func (r CustomerAPICustomerSetDefaultAddressRequest) Body(body CustomerSetDefaultAddressRequest) CustomerAPICustomerSetDefaultAddressRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSetDefaultAddressRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerSetDefaultAddressExecute(r)
}

/*
CustomerSetDefaultAddress Method for CustomerSetDefaultAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSetDefaultAddressRequest
*/
func (a *CustomerAPIService) CustomerSetDefaultAddress(ctx context.Context) CustomerAPICustomerSetDefaultAddressRequest {
	return CustomerAPICustomerSetDefaultAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerSetDefaultAddressExecute(r CustomerAPICustomerSetDefaultAddressRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSetDefaultAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/set_default_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSetDefaultAddress2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSetDefaultAddressRequest
}

func (r CustomerAPICustomerSetDefaultAddress2Request) Body(body CustomerSetDefaultAddressRequest) CustomerAPICustomerSetDefaultAddress2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSetDefaultAddress2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerSetDefaultAddress2Execute(r)
}

/*
CustomerSetDefaultAddress2 Method for CustomerSetDefaultAddress2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSetDefaultAddress2Request
*/
func (a *CustomerAPIService) CustomerSetDefaultAddress2(ctx context.Context) CustomerAPICustomerSetDefaultAddress2Request {
	return CustomerAPICustomerSetDefaultAddress2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerSetDefaultAddress2Execute(r CustomerAPICustomerSetDefaultAddress2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSetDefaultAddress2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/SetDefaultAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSetPermissionsRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSetPermissionsRequest
}

func (r CustomerAPICustomerSetPermissionsRequest) Body(body CustomerSetPermissionsRequest) CustomerAPICustomerSetPermissionsRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSetPermissionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerSetPermissionsExecute(r)
}

/*
CustomerSetPermissions Method for CustomerSetPermissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSetPermissionsRequest
*/
func (a *CustomerAPIService) CustomerSetPermissions(ctx context.Context) CustomerAPICustomerSetPermissionsRequest {
	return CustomerAPICustomerSetPermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerSetPermissionsExecute(r CustomerAPICustomerSetPermissionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSetPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/set_permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerSetPermissions2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerSetPermissionsRequest
}

func (r CustomerAPICustomerSetPermissions2Request) Body(body CustomerSetPermissionsRequest) CustomerAPICustomerSetPermissions2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerSetPermissions2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerSetPermissions2Execute(r)
}

/*
CustomerSetPermissions2 Method for CustomerSetPermissions2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerSetPermissions2Request
*/
func (a *CustomerAPIService) CustomerSetPermissions2(ctx context.Context) CustomerAPICustomerSetPermissions2Request {
	return CustomerAPICustomerSetPermissions2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerSetPermissions2Execute(r CustomerAPICustomerSetPermissions2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerSetPermissions2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/SetPermissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUnassignAgentRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUnassignAgentRequest
}

func (r CustomerAPICustomerUnassignAgentRequest) Body(body CustomerUnassignAgentRequest) CustomerAPICustomerUnassignAgentRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUnassignAgentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CustomerUnassignAgentExecute(r)
}

/*
CustomerUnassignAgent Method for CustomerUnassignAgent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUnassignAgentRequest
*/
func (a *CustomerAPIService) CustomerUnassignAgent(ctx context.Context) CustomerAPICustomerUnassignAgentRequest {
	return CustomerAPICustomerUnassignAgentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *CustomerAPIService) CustomerUnassignAgentExecute(r CustomerAPICustomerUnassignAgentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUnassignAgent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/UnassignAgent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUnsubscribeRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUnsubscribeRequest
}

func (r CustomerAPICustomerUnsubscribeRequest) Body(body CustomerUnsubscribeRequest) CustomerAPICustomerUnsubscribeRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUnsubscribeRequest) Execute() (*CustomerUnsubscribeResponse, *http.Response, error) {
	return r.ApiService.CustomerUnsubscribeExecute(r)
}

/*
CustomerUnsubscribe Method for CustomerUnsubscribe

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUnsubscribeRequest
*/
func (a *CustomerAPIService) CustomerUnsubscribe(ctx context.Context) CustomerAPICustomerUnsubscribeRequest {
	return CustomerAPICustomerUnsubscribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerUnsubscribeResponse
func (a *CustomerAPIService) CustomerUnsubscribeExecute(r CustomerAPICustomerUnsubscribeRequest) (*CustomerUnsubscribeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerUnsubscribeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUnsubscribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/unsubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUnsubscribe2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUnsubscribeRequest
}

func (r CustomerAPICustomerUnsubscribe2Request) Body(body CustomerUnsubscribeRequest) CustomerAPICustomerUnsubscribe2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUnsubscribe2Request) Execute() (*CustomerUnsubscribeResponse, *http.Response, error) {
	return r.ApiService.CustomerUnsubscribe2Execute(r)
}

/*
CustomerUnsubscribe2 Method for CustomerUnsubscribe2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUnsubscribe2Request
*/
func (a *CustomerAPIService) CustomerUnsubscribe2(ctx context.Context) CustomerAPICustomerUnsubscribe2Request {
	return CustomerAPICustomerUnsubscribe2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerUnsubscribeResponse
func (a *CustomerAPIService) CustomerUnsubscribe2Execute(r CustomerAPICustomerUnsubscribe2Request) (*CustomerUnsubscribeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerUnsubscribeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUnsubscribe2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/Unsubscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateRequest
}

func (r CustomerAPICustomerUpdateRequest) Body(body CustomerUpdateRequest) CustomerAPICustomerUpdateRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateRequest) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateExecute(r)
}

/*
CustomerUpdate Method for CustomerUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateRequest
*/
func (a *CustomerAPIService) CustomerUpdate(ctx context.Context) CustomerAPICustomerUpdateRequest {
	return CustomerAPICustomerUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerUpdateExecute(r CustomerAPICustomerUpdateRequest) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdate2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateRequest
}

func (r CustomerAPICustomerUpdate2Request) Body(body CustomerUpdateRequest) CustomerAPICustomerUpdate2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdate2Request) Execute() (*CustomerCustomerResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdate2Execute(r)
}

/*
CustomerUpdate2 Method for CustomerUpdate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdate2Request
*/
func (a *CustomerAPIService) CustomerUpdate2(ctx context.Context) CustomerAPICustomerUpdate2Request {
	return CustomerAPICustomerUpdate2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerCustomerResponse
func (a *CustomerAPIService) CustomerUpdate2Execute(r CustomerAPICustomerUpdate2Request) (*CustomerCustomerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerCustomerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/Update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateAddressRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressUpdateRequest
}

func (r CustomerAPICustomerUpdateAddressRequest) Body(body CustomerAddressUpdateRequest) CustomerAPICustomerUpdateAddressRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateAddressRequest) Execute() (*CustomerAddressUpdateResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateAddressExecute(r)
}

/*
CustomerUpdateAddress Method for CustomerUpdateAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateAddressRequest
*/
func (a *CustomerAPIService) CustomerUpdateAddress(ctx context.Context) CustomerAPICustomerUpdateAddressRequest {
	return CustomerAPICustomerUpdateAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressUpdateResponse
func (a *CustomerAPIService) CustomerUpdateAddressExecute(r CustomerAPICustomerUpdateAddressRequest) (*CustomerAddressUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/update_address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateAddress2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerAddressUpdateRequest
}

func (r CustomerAPICustomerUpdateAddress2Request) Body(body CustomerAddressUpdateRequest) CustomerAPICustomerUpdateAddress2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateAddress2Request) Execute() (*CustomerAddressUpdateResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateAddress2Execute(r)
}

/*
CustomerUpdateAddress2 Method for CustomerUpdateAddress2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateAddress2Request
*/
func (a *CustomerAPIService) CustomerUpdateAddress2(ctx context.Context) CustomerAPICustomerUpdateAddress2Request {
	return CustomerAPICustomerUpdateAddress2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerAddressUpdateResponse
func (a *CustomerAPIService) CustomerUpdateAddress2Execute(r CustomerAPICustomerUpdateAddress2Request) (*CustomerAddressUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerAddressUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateAddress2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/UpdateAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateGroupRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateGroupRequest
}

func (r CustomerAPICustomerUpdateGroupRequest) Body(body CustomerUpdateGroupRequest) CustomerAPICustomerUpdateGroupRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateGroupRequest) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateGroupExecute(r)
}

/*
CustomerUpdateGroup Method for CustomerUpdateGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateGroupRequest
*/
func (a *CustomerAPIService) CustomerUpdateGroup(ctx context.Context) CustomerAPICustomerUpdateGroupRequest {
	return CustomerAPICustomerUpdateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerUpdateGroupExecute(r CustomerAPICustomerUpdateGroupRequest) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/update_segment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateGroup2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateGroupRequest
}

func (r CustomerAPICustomerUpdateGroup2Request) Body(body CustomerUpdateGroupRequest) CustomerAPICustomerUpdateGroup2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateGroup2Request) Execute() (*CustomerGroupResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateGroup2Execute(r)
}

/*
CustomerUpdateGroup2 Method for CustomerUpdateGroup2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateGroup2Request
*/
func (a *CustomerAPIService) CustomerUpdateGroup2(ctx context.Context) CustomerAPICustomerUpdateGroup2Request {
	return CustomerAPICustomerUpdateGroup2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerGroupResponse
func (a *CustomerAPIService) CustomerUpdateGroup2Execute(r CustomerAPICustomerUpdateGroup2Request) (*CustomerGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateGroup2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/UpdateGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateSubscriberRequest struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateSubscriberRequest
}

func (r CustomerAPICustomerUpdateSubscriberRequest) Body(body CustomerUpdateSubscriberRequest) CustomerAPICustomerUpdateSubscriberRequest {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateSubscriberRequest) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateSubscriberExecute(r)
}

/*
CustomerUpdateSubscriber Method for CustomerUpdateSubscriber

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateSubscriberRequest
*/
func (a *CustomerAPIService) CustomerUpdateSubscriber(ctx context.Context) CustomerAPICustomerUpdateSubscriberRequest {
	return CustomerAPICustomerUpdateSubscriberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerUpdateSubscriberExecute(r CustomerAPICustomerUpdateSubscriberRequest) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateSubscriber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer/update_subscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CustomerAPICustomerUpdateSubscriber2Request struct {
	ctx context.Context
	ApiService CustomerAPI
	body *CustomerUpdateSubscriberRequest
}

func (r CustomerAPICustomerUpdateSubscriber2Request) Body(body CustomerUpdateSubscriberRequest) CustomerAPICustomerUpdateSubscriber2Request {
	r.body = &body
	return r
}

func (r CustomerAPICustomerUpdateSubscriber2Request) Execute() (*CustomerSubscriberResponse, *http.Response, error) {
	return r.ApiService.CustomerUpdateSubscriber2Execute(r)
}

/*
CustomerUpdateSubscriber2 Method for CustomerUpdateSubscriber2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CustomerAPICustomerUpdateSubscriber2Request
*/
func (a *CustomerAPIService) CustomerUpdateSubscriber2(ctx context.Context) CustomerAPICustomerUpdateSubscriber2Request {
	return CustomerAPICustomerUpdateSubscriber2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerSubscriberResponse
func (a *CustomerAPIService) CustomerUpdateSubscriber2Execute(r CustomerAPICustomerUpdateSubscriber2Request) (*CustomerSubscriberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerSubscriberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerAPIService.CustomerUpdateSubscriber2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/customer.Customer/UpdateSubscriber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
